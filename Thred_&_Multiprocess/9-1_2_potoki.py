"""Написать функцию find_primes(end, start), которая ищет все простые числа в диапазоне от заданного
числа start (по умолчанию 3) до заданного числа end. Далее необходимо:
Запустить ее три раза последовательно в диапазоне от 3 до 10000, от 10001 до 20000, от 20001 до 30000.
Запустить ее три раза с теми же аргументами, но каждый раз в отдельном потоке с помощью threading.Thread.
Что будет, если 'забыть' выполнить start или join для потоков?"""
import math
import time
import threading


def find_primes(end, start=3):
    print('Старт вычислений при end = {}'.format(end))
    lst = []
    while True:
        for x in range(2, int(math.sqrt(start) + 1)):
            if start % x == 0:
                break
        else:
            lst.append(start)
        start += 1
        if start > end:
            return lst, print('Конец вычислений при end = {}'.format(end))


start_time = time.time()
print("Так работают потоки")
threads = []
thr_1 = threading.Thread(target=find_primes, args=(1000000,))  # просто создание потока !!!
thr_1.start()  # запуск потока
threads.append(thr_1)

thr_2 = threading.Thread(target=find_primes, args=(2000000, 1000001))
thr_2.start()
threads.append(thr_2)

thr_3 = threading.Thread(target=find_primes, args=(3000000, 2000001))
thr_3.start()
threads.append(thr_3)

for thr in threads:
    thr.join()  # метод join означает, что основной (main) поток будет дожидаться выполнения и завершения
    # всех трёх потоков
print(time.time() - start_time)

start_time = time.time()


"""Если 'забыть' выполнить start, то выйдет ошибка "cannot join thread before it is started", т.е. мы не можем 
выполнить join без запуска потока (метод start)"""

"""Если join убрать, то основной (main) поток не будет никого ждать, в частности, он может посчитать время выполнения
не дождавшись выполнения всех трёх дочерних потоков. Вообще есть такое понятие 'дочерний поток ????' """

""" Время выполнения задачи всегда разное, как я понял это завист от нагруженности самой системы в определённый 
момент времени но примерно и так уже видно, что потоки работают МЕДЛЕННЕЕ, чем обычное 
последовательное выполнение... в чём причина? То, что при запуске кода идут вычисления, а значит задействован 
процессор. Потоки дают выгоду только там, где не используется процессор (нет вычислений). Плюс опять же надо время
на создание потоков. Если бы функция find_primes 'засыпала' на некоторое время, например в середине своего 
выполнения, то тогда да, потоки дали бы выгоду по времени. Пример засыпания (задержки) - ожидание ввода пользователя 
(вызов input) """